<rules category="jazz">
  <metadata>
    <trigger>glob</trigger>
    <globs>*.ts,*.tsx</globs>
  </metadata>

  <rule severity="CRITICAL" enforcement="BLOCKING">
    <name>Field Existence Checking with $jazz.has()</name>
    <description>Use `$jazz.has("field")` NOT `!obj.field` to check if optional fields exist. Optional fields may be unloaded but exist in the database.</description>
    <rationale>Checking with !obj.field can return false for unloaded fields, leading to data loss when re-initializing them</rationale>
    <mustAcknowledge>true</mustAcknowledge>
    <examples>
      <example type="wrong">
        if (!player.rounds) {
          player.$jazz.set("rounds", ListOfRounds.create([]));
        }
      </example>
      <example type="correct">
        if (!player.$jazz.has("rounds")) {
          player.$jazz.set("rounds", ListOfRounds.create([]));
        }
      </example>
    </examples>
    <instructions>
      Always use `$jazz.has("field")` to check if optional fields exist before initializing them. Never use truthiness checks on optional fields.
    </instructions>
  </rule>

  <rule severity="CRITICAL" enforcement="BLOCKING">
    <name>ensureLoaded After upsertUnique</name>
    <description>After `upsertUnique`, always `ensureLoaded` before checking optional fields.</description>
    <rationale>upsertUnique may return partially loaded objects. Checking fields without loading leads to false negatives.</rationale>
    <mustAcknowledge>true</mustAcknowledge>
    <examples>
      <example type="correct">
        player = await Player.upsertUnique({ value, unique, owner });
        const loaded = await player.$jazz.ensureLoaded({ resolve: { rounds: true } });
        if (!loaded.$jazz.has("rounds")) {
          // safe to initialize
        }
      </example>
    </examples>
    <instructions>
      Always call ensureLoaded after upsertUnique with the appropriate resolve structure before accessing optional fields.
    </instructions>
  </rule>

  <rule severity="CRITICAL" enforcement="BLOCKING">
    <name>Check $isLoaded Before Using Jazz API</name>
    <description>Always check `obj.$isLoaded` before calling `obj.$jazz.set()`, `obj.$jazz.owner`, or other Jazz API methods. TypeScript cannot infer that these properties exist on unloaded objects.</description>
    <rationale>Jazz objects can be in NotLoaded state where $jazz API is not available. TypeScript will error if you try to access $jazz properties without checking $isLoaded first.</rationale>
    <mustAcknowledge>true</mustAcknowledge>
    <examples>
      <example type="wrong">
        const root = me.root;
        if (root) {
          root.$jazz.set("player", player); // ERROR: $jazz might not exist
        }
      </example>
      <example type="correct">
        const root = me.root;
        if (!root?.$isLoaded) {
          await root.$jazz.ensureLoaded({});
        }
        if (root.$isLoaded) {
          root.$jazz.set("player", player); // OK: TypeScript knows root is loaded
        }
      </example>
      <example type="correct_alternative">
        // Or use ensureLoaded on parent and check result
        const loadedMe = await me.$jazz.ensureLoaded({ resolve: { root: true } });
        if (loadedMe.root?.$isLoaded) {
          loadedMe.root.$jazz.set("player", player);
        }
      </example>
    </examples>
    <instructions>
      - Always check `$isLoaded` before accessing `$jazz` API methods
      - Use `obj?.$isLoaded` checks or `ensureLoaded()` to guarantee objects are loaded
      - TypeScript will not let you access $jazz properties on possibly-unloaded objects
      - This prevents runtime errors from calling methods on NotLoaded objects
    </instructions>
  </rule>

  <rule severity="CRITICAL" enforcement="BLOCKING">
    <name>Lazy Loading Lists Level-by-Level</name>
    <description>Jazz CoLists must be loaded explicitly at each level. Nested $each does NOT load list items - it only resolves nested data IF items are already loaded.</description>
    <rationale>Common misconception that $each loads the list. It doesn't - you must explicitly load each list level.</rationale>
    <mustAcknowledge>true</mustAcknowledge>
    <examples>
      <example type="wrong">
        await hole.$jazz.ensureLoaded({
          resolve: {
            teams: {
              $each: {  // This won't load teams if they aren't loaded already!
                rounds: { $each: { roundToGame: true } }
              }
            }
          }
        });
      </example>
      <example type="correct">
        await hole.teams.$jazz.ensureLoaded({});  // Load teams list
        for (const team of hole.teams) {
          await team.$jazz.ensureLoaded({});  // Load team object
          await team.rounds.$jazz.ensureLoaded({});  // Load rounds list
          for (const round of team.rounds) {
            await round.$jazz.ensureLoaded({ resolve: { roundToGame: true } });
          }
        }
      </example>
    </examples>
    <instructions>
      Load lists explicitly level-by-level. Use $each only to resolve nested data on already-loaded list items, not to load the list itself.
    </instructions>
  </rule>

  <rule severity="HIGH" enforcement="STRICT">
    <name>ensureLoaded is Async</name>
    <description>Always await ensureLoaded calls. They are asynchronous operations.</description>
    <examples>
      <example type="correct">
        await player.$jazz.ensureLoaded({ resolve: { rounds: true } });  // MUST await
      </example>
    </examples>
    <instructions>
      Never forget to await ensureLoaded() calls. Missing await can cause race conditions and unloaded data access.
    </instructions>
  </rule>

  <rule severity="CRITICAL" enforcement="BLOCKING">
    <name>Never Store Jazz Objects in React State</name>
    <description>NEVER store Jazz CoValues (Game, Player, etc.) in React state (useState, useContext). Store IDs instead.</description>
    <rationale>Jazz objects are reactive and update references as nested data loads. Storing them in React state causes excessive re-renders (20-40+) as each progressive load creates a new reference, triggering React's change detection.</rationale>
    <mustAcknowledge>true</mustAcknowledge>
    <examples>
      <example type="wrong">
        // GameContext storing the Game object - CAUSES 24+ RE-RENDERS!
        const [game, setGame] = useState&lt;Game | null&gt;(null);

        useEffect(() => {
          if (game?.$isLoaded) {
            setGame(game); // Triggers re-render on every nested data load
          }
        }, [game]);
      </example>
      <example type="correct">
        // GameContext storing only the gameId string
        const [gameId, setGameId] = useState&lt;string | null&gt;(null);

        // Components use useCoState directly
        const game = useCoState(Game, gameId || "", { resolve: {...} });
      </example>
    </examples>
    <performance_impact>
      <before>24+ re-renders over 3+ seconds as nested data loads</before>
      <after>1 render when selector returns fully loaded data</after>
      <speedup>55% faster perceived loading time</speedup>
    </performance_impact>
    <instructions>
      - Store IDs (strings) in React state/context, NEVER Jazz objects
      - Use useCoState directly in components that need the data
      - Let Jazz's reactivity handle updates, not React's state system
      - Use selectors in useCoState to control when components re-render
    </instructions>
  </rule>

  <rule severity="HIGH" enforcement="STRICT">
    <name>Avoid React Hooks with Jazz Data</name>
    <description>Minimize useState, useMemo, useEffect with Jazz data. Use Jazz hooks and functions instead.</description>
    <rationale>Jazz provides reactive data updates. Wrapping Jazz in React patterns creates unnecessary complexity, bugs, and performance issues.</rationale>
    <react_patterns_to_avoid>
      <pattern name="useState">Never store Jazz objects in state</pattern>
      <pattern name="useMemo">Don't memoize Jazz data - just access it directly</pattern>
      <pattern name="useEffect">Don't sync Jazz data in effects - use selectors instead</pattern>
      <pattern name="useCallback">Only for event handlers, never for Jazz data access</pattern>
    </react_patterns_to_avoid>
    <examples>
      <example type="wrong">
        // Fighting Jazz reactivity with React patterns
        const [game, setGame] = useState&lt;Game | null&gt;(null);

        const facilityName = useMemo(() => {
          if (!game?.$isLoaded) return undefined;
          return getFacilityName(game);
        }, [game]); // Recomputes on every progressive load

        useEffect(() => {
          if (game?.$isLoaded) {
            setGame(game); // Causes re-renders
          }
        }, [game]);
      </example>
      <example type="correct">
        // Embracing Jazz reactivity
        const game = useCoState(Game, gameId, {
          resolve: {...},
          select: (g) => g.$isLoaded ? g : undefined
        });

        // Just access directly - no useMemo needed
        const facilityName = game?.$isLoaded ? getFacilityName(game) : undefined;

        // No useEffect needed - Jazz is already reactive
      </example>
    </examples>
    <instructions>
      - Use Jazz's reactive data system directly with useCoState
      - Use selectors to control when data is "ready"
      - Only use useState for truly local UI state (modals, form inputs, toggles)
      - Only use useEffect for side effects (navigation, API calls), not data syncing
      - Just access Jazz data directly - no need for useMemo
    </instructions>
  </rule>

  <rule severity="CRITICAL" enforcement="BLOCKING">
    <name>Keep High-Level Subscriptions Shallow</name>
    <description>High-level components that stay mounted (navigators, screens) should NOT deeply resolve nested objects in subscriptions. Let child components load their own data.</description>
    <rationale>Deep resolution in high-level subscriptions causes "value is unavailable" errors during progressive loading. When a parent component subscribes deeply (e.g., course.name, tee.holes), it tries to access partially loaded nested data during Jazz's progressive loading cycle, triggering errors when toString() is called on CoValueLoadingState.</rationale>
    <mustAcknowledge>true</mustAcknowledge>
    <examples>
      <example type="wrong">
        // High-level screen resolving deeply - CAUSES ERRORS
        const { game } = useGame(undefined, {
          resolve: {
            players: {
              $each: {
                rounds: {
                  $each: {
                    course: { name: true },  // Deep resolution in high-level subscription
                    tee: { name: true, ratings: { total: true } },
                  },
                },
              },
            },
          },
        });
      </example>
      <example type="correct">
        // High-level screen stays shallow
        const { game } = useGame(undefined, {
          resolve: {
            players: {
              $each: {
                rounds: {
                  $each: {
                    // Don't resolve course/tee here
                  },
                },
              },
            },
          },
        });

        // Child component loads its own data
        function RoundCourseTeeName({ round }: { round: MaybeLoaded&lt;Round&gt; | null }) {
          const [courseTeeName, setCourseTeeName] = useState&lt;string&gt;("Loading...");

          useEffect(() => {
            if (!round?.$isLoaded) return;

            const loadData = async () => {
              if (round.$jazz.has("course") &amp;&amp; round.$jazz.has("tee")) {
                await round.$jazz.ensureLoaded({
                  resolve: {
                    course: true,
                    tee: true,
                  },
                });
                setCourseTeeName(`${round.course?.name} • ${round.tee?.name}`);
              }
            };
            loadData();
          }, [round]);

          return &lt;Text&gt;{courseTeeName}&lt;/Text&gt;;
        }
      </example>
    </examples>
    <pattern>
      <principle>High-level components: Keep subscriptions shallow</principle>
      <principle>Child components: Load their own deep data asynchronously</principle>
      <principle>Use useEffect + ensureLoaded in child components</principle>
      <principle>Check $jazz.has("field") before loading optional nested fields</principle>
    </pattern>
    <instructions>
      - High-level components (navigators, screens) should only resolve shallow data
      - Never resolve nested objects deeply (course.name, tee.holes) in high-level subscriptions
      - Create child components that load their own nested data using useEffect + ensureLoaded
      - This prevents accessing partially loaded data during progressive loading
      - Pattern: Parent subscribes shallow, children load deep asynchronously
    </instructions>
  </rule>

  <rule severity="HIGH" enforcement="STRICT">
    <name>Modify Entities from Authoritative Source</name>
    <description>Always modify entities from the authoritative source (e.g., game context), not from stale references.</description>
    <examples>
      <example type="wrong">
        const { player } = route.params;
        player.rounds.$jazz.push(newRound);
      </example>
      <example type="correct">
        const gamePlayer = game.players.find(p => p?.$jazz.id === player.$jazz.id);
        gamePlayer.rounds.$jazz.push(newRound);
      </example>
    </examples>
    <instructions>
      Always retrieve the current version of an entity from its authoritative context before modification to avoid working with stale references.
    </instructions>
  </rule>

  <rule severity="HIGH" enforcement="STRICT">
    <name>Creating CoMaps with Optional Fields</name>
    <description>When creating CoMaps, pass only required fields to `.create()`. Set optional fields AFTER creation.</description>
    <rationale>Jazz .create() expects plain values, not CoMap instances. Passing CoMaps in initial value causes "right operand of 'in' is not an object" errors.</rationale>
    <examples>
      <example type="wrong">
        const scope = GameScope.create(
          {
            holes: "all18",
            teamsConfig: someTeamsConfig,  // ERROR: Can't pass CoMap instances
          },
          { owner: group }
        );
      </example>
      <example type="correct">
        const scope = GameScope.create(
          {
            holes: "all18",
          },
          { owner: group }
        );
        // Set optional CoMap field after creation
        if (teamsConfig) {
          scope.$jazz.set("teamsConfig", teamsConfig);
        }
      </example>
    </examples>
    <instructions>
      Create CoMaps with only required primitive fields. Use $jazz.set() to add optional fields, especially if they are other CoMaps.
    </instructions>
  </rule>

  <rule severity="HIGH" enforcement="STRICT">
    <name>Use Selectors to Control Re-renders</name>
    <description>Use the `select` option in useCoState to batch updates and prevent re-renders during progressive loading.</description>
    <rationale>Jazz loads nested data progressively. Without selectors, components re-render on every nested data load (20-40+ times). Selectors let you return `undefined` until all required data is loaded, then return the full object once.</rationale>
    <examples>
      <example type="wrong">
        // Re-renders 24+ times as nested data loads
        const game = useCoState(Game, gameId, {
          resolve: {
            rounds: { $each: { round: { course: true, scores: true } } }
          }
        });
      </example>
      <example type="correct">
        // Re-renders ONCE when all data is loaded
        const game = useCoState(Game, gameId, {
          resolve: {
            rounds: { $each: { round: { course: true, scores: true } } }
          },
          select: (value) => {
            if (!value.$isLoaded) return undefined;
            if (!value.rounds?.$isLoaded) return undefined;
            // Check all critical nested data is loaded
            for (const rtg of value.rounds) {
              if (!rtg?.$isLoaded) return undefined;
              if (!rtg.round?.$isLoaded) return undefined;
            }
            return value; // Only return when fully loaded
          }
        });
      </example>
    </examples>
    <instructions>
      - Use `select` in useCoState when loading nested data
      - Return `undefined` while data is loading
      - Return the full object only when all required data is loaded
      - This batches all progressive loads into a single render
    </instructions>
  </rule>

  <rule severity="HIGH" enforcement="STRICT">
    <name>Progressive Loading is the Default</name>
    <description>Jazz loads nested data progressively, not all at once. Understand this to avoid performance pitfalls.</description>
    <rationale>When you specify deep resolve structures, Jazz loads objects level-by-level. Each level loaded triggers a new object reference, which triggers React re-renders if not handled with selectors.</rationale>
    <loading_behavior>
      <step>1. Load parent object</step>
      <step>2. Load first-level references</step>
      <step>3. Load second-level references</step>
      <step>4. Continue until all resolve depth is loaded</step>
      <impact>Each step creates a new object reference</impact>
    </loading_behavior>
    <instructions>
      - Progressive loading is a feature, not a bug
      - Use selectors to control when components see the data
      - Don't fight progressive loading with React patterns (useEffect, useState)
      - Embrace Jazz reactivity instead of React state management
    </instructions>
  </rule>

  <rule severity="MEDIUM" enforcement="RECOMMENDED">
    <name>Performance: Load What You Need, When You Need It</name>
    <description>Optimize Jazz loading by loading data on-demand, not all upfront. Load current view's data, not all 18 holes.</description>
    <loading_strategy>
      <strategy>Initial load: Load minimal data needed for first render</strategy>
      <strategy>Current view: Load only data for current screen/hole/tab</strategy>
      <strategy>On-demand: Use ensureLoaded() when user navigates to new sections</strategy>
      <strategy>Shallow first: Load lists shallowly, then load individual items as needed</strategy>
    </loading_strategy>
    <examples>
      <example type="wrong">
        // Loading all 18 holes with full teams/rounds/scores - 100+ CoValue objects!
        const game = useCoState(Game, gameId, {
          resolve: {
            holes: {
              $each: {
                teams: {
                  $each: {
                    rounds: { $each: { roundToGame: { round: { scores: true } } } }
                  }
                }
              }
            }
          }
        });
      </example>
      <example type="correct">
        // Load holes shallowly, only load current hole's teams
        const game = useCoState(Game, gameId, {
          resolve: { holes: true, rounds: { $each: true } }
        });

        // Separate hook for current hole only
        const currentHole = useCoState(GameHole, currentHoleId, {
          resolve: {
            teams: {
              $each: { rounds: { $each: { roundToGame: true } } }
            }
          },
          select: (hole) => {
            // Only return when current hole is fully loaded
            if (!hole.$isLoaded) return null;
            if (!hole.teams?.$isLoaded) return null;
            for (const team of hole.teams) {
              if (!team?.$isLoaded || !team.rounds?.$isLoaded) return null;
            }
            return hole;
          }
        });
      </example>
    </examples>
    <performance_impact>
      <wrong_way>Loading 18 holes × 2 teams × 2 rounds = 72+ objects = slow</wrong_way>
      <right_way>Loading 1 hole × 2 teams × 2 rounds = 4 objects = fast</right_way>
    </performance_impact>
    <instructions>
      Don't over-fetch data. Load only what the current view needs, load more as user navigates.
    </instructions>
  </rule>

  <rule severity="MEDIUM" enforcement="RECOMMENDED">
    <name>Circular Dependencies with String IDs</name>
    <description>Avoid circular dependencies between CoMaps by using string IDs instead of direct references.</description>
    <examples>
      <example type="pattern">
        // Round uses playerId: z.string() instead of player: Player
        // Player can have rounds: co.optional(ListOfRounds)
      </example>
    </examples>
    <instructions>
      When two entities would reference each other, use string IDs in one direction to break the circular dependency.
    </instructions>
  </rule>

  <rule severity="MEDIUM" enforcement="RECOMMENDED">
    <name>Jazz API Patterns</name>
    <description>Common Jazz API patterns for working with data</description>
    <api_patterns>
      <pattern>Set optional fields: `obj.$jazz.set("field", value)`</pattern>
      <pattern>Add to list: `list.$jazz.push(item)`</pattern>
      <pattern>Get owner: `obj.$jazz.owner`</pattern>
      <pattern>Get ID: `obj.$jazz.id`</pattern>
      <pattern>Check loaded: `obj.$isLoaded`</pattern>
      <pattern>Check loading state: `obj.$jazz.loadingState`</pattern>
      <pattern>Check field exists: `obj.$jazz.has("field")`</pattern>
    </api_patterns>
    <instructions>
      Use these standard Jazz patterns consistently across the codebase.
    </instructions>
  </rule>

  <rule severity="MEDIUM" enforcement="RECOMMENDED">
    <name>Debugging Loading Issues</name>
    <description>Tools for debugging Jazz loading problems</description>
    <debugging_tools>
      <tool>`$isLoaded` - Check if object is fully loaded</tool>
      <tool>`$jazz.loadingState` - Check loading state (undefined = not tried yet)</tool>
      <tool>`$jazz.has("field")` - Check if optional field exists in DB</tool>
    </debugging_tools>
    <instructions>
      When data isn't loading as expected, check loadingState and $isLoaded to diagnose the issue.
    </instructions>
  </rule>

  <rule severity="LOW" enforcement="ADVISORY">
    <name>Jazz Documentation</name>
    <description>Jazz Tools documentation is available at https://jazz.tools/docs and via Context7 MCP</description>
    <instructions>
      For detailed Jazz Tools API documentation, check https://jazz.tools/docs or use the Context7 MCP to fetch library docs.
    </instructions>
  </rule>
</rules>
